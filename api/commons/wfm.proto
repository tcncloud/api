syntax = "proto3";

package api.commons;

import "google/protobuf/timestamp.proto";

// Represents the skill types that a client's skills can be.
message SkillType {
  enum Enum {
    AGENT_SKILL = 0;
    HUNT_GROUP = 1;
    AGENT_PBX = 2; // NOT used by WFM.
    HUNT_GROUP_PBX = 3; // NOT used by WFM.
    PBX = 4;
    AGENT = 5; // NOT used by WFM.
  }
}

// Enum representing the different types of models for the regression forecaster.
enum RegressionForecasterModelTypes {
  RANDOM_FOREST = 0;
  ADABOOST = 1;
  GRADIENT_BOOSTING = 2;
  LINEAR_REGRESSION = 3;
  LINEAR_AVG = 4;
  SEGMENTED_LINEAR = 5;
  MLP = 6;
  AUTO = 7;
}

message DatetimeRange {
  // begining datetime
  google.protobuf.Timestamp start_datetime = 1;
  // ending datetime
  google.protobuf.Timestamp end_datetime = 2;
}

// Request message for the UpsertForecastingParameters RPC.
message ForecastingParameters {
  reserved 2, 3, 4, 5;
  // number of minutes in which calls will be grouped together during for the duration of a forecast, must be a multiple of 5 ranging from 5 to 60.
  int32 interval_width_in_minutes = 1;

  // period for training that the historical data will be sourced from.
  // can be either a number of months to go back from the current datetime or a datetime to start from until the present.
  oneof historical_data_range {
    // number of months back from the current datetime to look up history.
    int32 historical_data_range_in_months = 6;
    //start datetime to look up the history (end time will be the current datetime).
    google.protobuf.Timestamp historical_data_range_start_datetime = 7;
  }

  // number of weeks of the training data from the current datetime to use as a forecast test range.
  int32 forecast_test_range_in_weeks = 8;

  // date range to generate forecasts.
  oneof forecast_range {
    // number of weeks from the current datetime that forecast will be made.
    int32 forecast_range_in_weeks = 9;
    // date range at which a forecasts will be made.
    DatetimeRange forecast_datetime_range = 10;
  }

  // date range to be used to generate training data.
  oneof training_data_range {
    // number of months in the past from the current datetime that the training data will be generated from.
    int32 training_data_range_in_months = 11;
    // date range in which the training data will be generated.
    DatetimeRange training_data_datetime_range = 12;
  }

  // Number of months of training data to use when calculating averages.
  // If set to 0, then all the training data will be used when calculating the averages,
  // meaning that the start datetime of the training data to use will be the start datetime of the @training_data_range.
  // Otherwise, it will subtract that many months from the @training_data_range end datetime and use it as the start time.
  int32 averages_calculation_range_in_months = 13;
}

// ----------------------- Message types used by BuildProfileForecastReq() ------------------
// a profile for time of day, for each day of the week
message ProfileTOD {
  repeated float sunday = 1;
  repeated float monday = 2;
  repeated float tuesday = 3;
  repeated float wednesday = 4;
  repeated float thursday = 5;
  repeated float friday = 6;
  repeated float saturday = 7;
}

// a profile for week of month, for each month of the year
message ProfileWOMS {
  repeated float january = 1;
  repeated float february = 2;
  repeated float march = 3;
  repeated float april = 4;
  repeated float may = 5;
  repeated float june = 6;
  repeated float july = 7;
  repeated float august = 8;
  repeated float september = 9;
  repeated float october = 10;
  repeated float november = 11;
  repeated float december = 12;
}

// a profile each day of the week
message ProfileDOW {
  float sunday = 1;
  float monday = 2;
  float tuesday = 3;
  float wednesday = 4;
  float thursday = 5;
  float friday = 6;
  float saturday = 7;
}

// a profile for each month of the year
message ProfileMOY {
  float january = 1;
  float february = 2;
  float march = 3;
  float april = 4;
  float may = 5;
  float june = 6;
  float july = 7;
  float august = 8;
  float september = 9;
  float october = 10;
  float november = 11;
  float december = 12;
}

// note that for any of the profile_XX fields below, if a profile has length 0, then a profile value of 1.0 is assumed for that profile
// Each profile element is in the range 0..1 inclusive

message DistributionProfile {
  // For each of the 7 days of the week, a list of intervals signifying the distribution by time of day in intervals
  // determined by interval_minutes, starting with interval 0 = 12AM. so there would be 96 element for 15-minute intervals
  ProfileTOD profile_tod = 1;
  // For each of the 12 months of the year, a list of 6 week profiles. The first index for a given month is week 1 : the week
  //   of the first day of the month. The week with the last day of the month is the last index. e.g August 2021 has
  //   6 'weeks'
  ProfileWOMS profile_woms = 2;
  // a profile for each day of the week
  ProfileDOW profile_dow = 3;
  // a profile for each month of the year
  ProfileMOY profile_moy = 4;
}

// defines a template profile for call count distributions
message CallProfileGroupCalls {
  int32 total_calls = 1;

  DistributionProfile distribution_profile = 2;
}

// defines a template profile of call characteristic distributions
message CallProfileGroupAvgs {
  // min average (e.g. min ATAB)
  float min_average = 1;
  // max average (e.g. max ATAB)
  float max_average = 2;

  DistributionProfile distribution_profile = 3;
}

enum RegressionForecasterAvgsProcessingType {
  // a complete forecast is built for each skill profile for ACW/ASA/AHT/ATAB
  FORECAST = 0;
  // an average from the training data is built for each skill profile for ACW/ASA/AHT/ATAB
  AVERAGES = 1;
  // Fixed values are used for  ACW/ASA/AHT/ATAB
  FIXED_AVERAGES = 2;
}

/****************************************************************************************************************************************************/
/****************************************************************************************************************************************************/
/****************************************************************CONFIG/SCHEDULER**********************************************************************/
/****************************************************************************************************************************************************/
/****************************************************************************************************************************************************/

// enum representing the units of time a ConstraintRule uses
enum ConstraintTimeUnit {
  MINUTES = 0;
  HOURS = 1;
  SHIFTS = 2;
  DAYS = 3;
  WEEKS = 4;
  MONTHS = 5;
  YEARS = 6;
}

enum ConfigEntityType {
  // entity is a call center node.
  CALL_CENTER_NODE = 0;
  // entity is a client node.
  CLIENT_NODE = 1;
  // entity is a location node.
  LOCATION_NODE = 2;
  // entity is a program node.
  PROGRAM_NODE = 3;
  // entity is an agent group.
  AGENT_GROUP = 4;
  // entity is a shift template.
  SHIFT_TEMPLATE = 5;
  // entity is a wfm agent.
  WFM_AGENT = 6;
  // entity is a placement rule.
  PLACEMENT_RULE = 7;
  // entity is a constraint rule.
  CONSTRAINT_RULE = 8;
  // entity is a non skill activity.
  NON_SKILL_ACTIVITY = 9;
  // entity is an agent availability.
  AGENT_AVAILABILITY = 10;
  // entity is an open times.
  OPEN_TIMES = 11;
  // entity is a scheduling activity.
  SCHEDULING_ACTIVITY = 12;
  // entity is a skill proficiency.
  SKILL_PROFICIENCY = 13;
  // entity is a schedule scenario.
  SCHEDULE_SCENARIO = 14;
  // entity is a skill.
  SKILL = 15;
  // entity is a tour pattern.
  TOUR_PATTERN = 16;
  // entity is a tour week pattern.
  TOUR_WEEK_PATTERN = 17;
  // entity is a tour shift instance config.
  TOUR_SHIFT_INSTANCE_CONFIG = 18;
  // entity is a tour shift segment config.
  TOUR_SHIFT_SEGMENT_CONFIG = 19;
  // entity is a tour agent collection.
  TOUR_AGENT_COLLECTION = 20;
}

// enum representing the different types of Constraint Rules
enum ConstraintRuleType {
  MIN_CONSEC_ON = 0;
  MAX_CONSEC_ON = 1;
  MIN_CONSEC_OFF = 2;
  MAX_CONSEC_OFF = 3;
  MIN_TOTAL_ON = 4;
  MAX_TOTAL_ON = 5;
  MIN_TOTAL_OFF = 6;
  MAX_TOTAL_OFF = 7;
  MIN_SKILL_LEVEL = 8;
}

// Enum representing the different types of placements for the DOW Placement.
enum DOWPlacementType {
  MUST_NOT = 0;
  MAY = 1;
  MUST = 2;
}

// Enum representing the options for open times.
enum OpenTimesOption {
  CLOSED = 0;
  OPEN = 1;
}

// Enum representing the options for agent availability.
enum AvailabilityOption {
  AVAILABLE = 0;
  NOT_AVAILABLE = 1;
  PREFER_NOT_AVAILABLE = 2;
}

// Enum representing the options for day of the week, Monday must be 0.
enum DayOfWeek {
  MON = 0;
  TUE = 1;
  WED = 2;
  THU = 3;
  FRI = 4;
  SAT = 5;
  SUN = 6;
}

// Encapsulates the two kinds of options available so they can be interchangeably used.
message OptionTypes {
  oneof desired_option {
    // Option used by OpenTime
    OpenTimesOption open_times_option = 1;
    // Option used by Agent Availability
    AvailabilityOption availability_option = 2;
  }
}

// Enum representing the options for config entity relationships.
enum ConfigRelationshipType {
  // The entity is associated with the other one.
  IS_ASSOCIATED_WITH = 0;
  // The entity is NOT associated with the other one.
  IS_NOT_ASSOCIATED_WITH = 1;
  // The entity is a member of the other one.
  IS_MEMBER_OF = 2;
}

// Enum representing the level of a diagnostic.
enum DiagnosticLevel {
  // The diagnostic is reporting an information level report.
  INFORMATION = 0;
  // The diagnostic is reporting a suggestion level report.
  SUGGESTION = 1;
  // The diagnostic is reporting a warning level report.
  WARNING = 2;
  // The diagnostic is reporting an error level report.
  DIAGNOSTIC_ERROR = 3;
  // The diagnostic is reporting an internal error level report.
  INTERNAL_ERROR = 4;
}

// Enum representing the type of a diagnostic.
enum DiagnosticCode {
  // DiagnosticCodeGeneral integer value for a diagnostic coded as 'general' type.
  // The code type used when no other code is appropriate.
  // GENERAL means that this diagnostic message cannot be described by a code.
  // The consumer must interpret the text message for further details.
  GENERAL = 0;
  // DiagnosticCodeOk integer value for a diagnostic coded as 'ok' type.
  // The diagnostic is reporting no errors found.
  OK = 1;
  // DiagnosticCodeNoSkillsInDictionary integer value for a diagnostic coded as 'no skills in dictionary' type.
  // The diagnostic is reporting no skills in the dictionary.
  NO_SKILLS_IN_DICTIONARY = 2;
  // DiagnosticCodeAgentHasNoSkillProficiencies integer value for a diagnostic coded as
  // 'agent has no skill proficiencies' type.
  // The diagnostic is reporting a wfm agent with no skill proficiencies.
  AGENT_HAS_NO_SKILL_PROFICIENCIES = 3;
  // DiagnosticCodeAgentHasNoSkills integer value for a diagnostic coded as 'agent has no skills' type.
  // The diagnostic is reporting an agent with no skills.
  AGENT_HAS_NO_SKILLS = 4;
  // DiagnosticCodeNoSchedulingActivitiesForConstraintRules integer value for a diagnostic coded as
  // 'no scheduling activity for constraint rules' type.
  // The diagnostic is reporting the constraint rules don't have a scheduling activity.
  NO_SCHEDULING_ACTIVITIES_FOR_CONSTRAINT_RULES = 5;
  // DiagnosticCodeSchedulingActivityForConstraintRuleNotFound integer value for a diagnostic coded as
  // 'scheduling activity for constraint rule not found' type.
  // The diagnostic is reporting a constraint rule pointing to a scheduling activity that cannot be found.
  SCHEDULING_ACTIVITY_FOR_CONSTRAINT_RULE_NOT_FOUND = 6;
  // DiagnosticCodeShiftTemplateCannotBeNone integer value for a diagnostic coded as
  // 'shift template cannot be none' type.
  // The diagnostic is reporting a NONE value for a shift template
  SHIFT_TEMPLATE_CANNOT_BE_NONE = 7;
  // DiagnosticCodeShiftTemplateHasNoPlacementRules integer value for a diagnostic coded as
  // 'shift template has no placement rules' type.
  // The diagnostic is reporting a shift template with no member placement rules.
  SHIFT_TEMPLATE_HAS_NO_PLACEMENT_RULES = 8;
  // DiagnosticCodeNoOncallInShiftTemplatePlacementRules integer value for a diagnostic coded as
  // 'no on-call in shift template placement rules' type.
  // The diagnostic is reporting a shift template whose placement rules do not include an on-call placement.
  NO_ONCALL_IN_SHIFT_TEMPLATE_PLACEMENT_RULES = 9;
  // DiagnosticCodeMinGtMaxDurationInShiftTemplatePlacementRules integer value for a diagnostic coded as
  // 'min greater than max in shift template placement rules' type.
  // The diagnostic is reporting the min duration for a shift templates placement rule is greater than max duration.
  MIN_GT_MAX_DURATION_IN_SHIFT_TEMPLATE_PLACEMENT_RULES = 10;
  // DiagnosticCodeMinGtMaxAgentsInShiftTemplate integer value for a diagnostic coded as
  // 'min greater than max agents in shift template' type.
  // The diagnostic is reporting a shift template with a min_agents value greater than it's max_agents value.
  MIN_GT_MAX_AGENTS_IN_SHIFT_TEMPLATE = 11;
  // DiagnosticCodeNoPlacementRulesForShiftTemplate integer value for a diagnostic coded as
  // 'no placement rules for shift template' type.
  // The diagnostic is reporting no placement rules as members of the shift template.
  NO_PLACEMENT_RULES_FOR_SHIFT_TEMPLATE = 12;
  // DiagnosticCodeActivitiesShorterThanShift integer value for a diagnostic coded as
  // 'activities shorter than shift' type.
  // The diagnostic is reporting that the activities are too short for the shift.
  ACTIVITIES_SHORTER_THAN_SHIFT = 13;
  // DiagnosticCodeNotEnoughAgentsForShift integer value for a diagnostic coded as 'not enough agents for shift' type.
  // The diagnostic is reporting that a shift doesn't have a sufficient number of agents available.
  NOT_ENOUGH_AGENTS_FOR_SHIFT = 14;
  // DiagnosticCodeProgramHasNoAgentGroups integer value for a diagnostic coded as 'program has no agent groups' type.
  // The diagnostic is reporting that a program node has no member agent groups.
  PROGRAM_HAS_NO_AGENT_GROUPS = 15;
  // DiagnosticCodeProgramHasNoShiftTemplates integer value for a diagnostic coded as
  // 'program has no shift templates' type.
  // The diagnostic is reporting that a program node has no member shift templates.
  PROGRAM_HAS_NO_SHIFT_TEMPLATES = 16;
  // DiagnosticCodeLocationHasNoPrograms integer value for a diagnostic coded as 'location has no programs' type.
  // The diagnostic is reporting that a location node has no member program nodes.
  LOCATION_HAS_NO_PROGRAMS = 17;
  // DiagnosticCodeClientHasNoLocations integer value for a diagnostic coded as 'client has no locations' type.
  // The diagnostic is reporting that a client node has no member location nodes.
  CLIENT_HAS_NO_LOCATIONS = 18;
  // DiagnosticCodeCallCenterHasNoClients integer value for a diagnostic coded as 'call center has no clients' type.
  // The diagnostic is reporting that a call center node has no member client nodes
  CALL_CENTER_HAS_NO_CLIENTS = 19;
  // DiagnosticCodeProgramHasInvalidParentLocation integer value for a diagnostic coded as
  // 'program has invalid parent location' type.
  // The diagnostic is reporting that a program node has an invalid parent location node.
  PROGRAM_HAS_INVALID_PARENT_LOCATION = 20;
  // DiagnosticCodeLocationHasInvalidParentClient integer value for a diagnostic coded as
  // 'location has invalid parent client' type.
  // The diagnostic is reporting that a location node has an invalid parent client node.
  LOCATION_HAS_INVALID_PARENT_CLIENT = 21;
  // DiagnosticCodeClientHasInvalidParentCallCenter integer value for a diagnostic coded as
  // 'client has invalid parent call center' type.
  // The diagnostic is reporting that a client node has an invalid parent call center.
  CLIENT_HAS_INVALID_PARENT_CALL_CENTER = 22;
  // DiagnosticCodeAgentGroupHasInvalidParentNode integer value for a diagnostic coded as
  // 'agent group has invalid parent node' type.
  // The diagnostic is reporting that an agent group has an invalid parent node.
  AGENT_GROUP_HAS_INVALID_PARENT_NODE = 23;
  // DiagnosticCodeShiftTemplateHasInvalidParentProgram integer value for a diagnostic coded as
  // 'shift template has invalid parent program' type.
  // The diagnostic is reporting an invalid parent program for a shift template.
  SHIFT_TEMPLATE_HAS_INVALID_PARENT_PROGRAM = 24;
  // DiagnosticCodeNoSkillProficiencyForMinSkillProficiencyConstraintRule integer value for a diagnostic coded as
  // 'skill proficiency for constraint rule not found' type.
  // The diagnostic is reporting a constraint rule pointing to a missing skill proficiency.
  NO_SKILL_PROFICIENCY_FOR_MIN_SKILL_PROFICIENCY_CONSTRAINT_RULE = 25;
  // DiagnosticCodeTooManyAgentsWithLockedShiftsForMinAgents integer value for a diagnostic coded as
  // 'too many agent with locked shifts' type.
  TOO_MANY_AGENTS_WITH_LOCKED_SHIFTS_FOR_MIN_AGENTS = 26;
  // DiagnosticCodeAgentDoesNotBelongToAnAgentGroup integer value for a diagnostic coded as
  // 'agent does not belong to an agent group' type.
  AGENT_DOES_NOT_BELONG_TO_AN_AGENT_GROUP = 27;
  // DiagnosticCodeInvalidConstraintValUnits integer value for a diagnostic coded as
  // 'Invalid constraint val units' type.
  INVALID_CONSTRAINT_VAL_UNITS = 28;
  // DiagnosticCodeConstraintGeneralFailure integer value for a diagnostic coded as 'Constraint general failure' type.
  CONSTRAINT_GENERAL_FAILURE = 29;
  // DiagnosticCodeCandidateShiftCollisionDetected integer value for a diagnostic coded as
  // 'Candidate shift collision detected' type.
  CANDIDATE_SHIFT_COLLISION_DETECTED = 30;
  // DiagnosticCodeCandidateShiftAgentNotAvailable integer value for a diagnostic coded as
  // 'Candidate shift agent not available' type.
  CANDIDATE_SHIFT_AGENT_NOT_AVAILABLE = 31;
  // DiagnosticCodeCandidateClosed integer value for a diagnostic coded as 'Candidate closed' type.
  CANDIDATE_CLOSED = 32;
  // DiagnosticCodeConstraintActivityNotFound integer value for a diagnostic coded as
  // 'Constraint activity not found' type.
  CONSTRAINT_ACTIVITY_NOT_FOUND = 33;
  // DiagnosticCodeConstraintAgentDoesNotHaveProficiency integer value for a diagnostic coded as
  // 'Constraint agent does not have proficiency' type.
  CONSTRAINT_AGENT_DOES_NOT_HAVE_PROFICIENCY = 34;
  // DiagnosticCodeConstraintAgentProficiencyTooLow integer value for a diagnostic coded as
  // 'Constraint agent proficiency too low' type.
  CONSTRAINT_AGENT_PROFICIENCY_TOO_LOW = 35;
  // DiagnosticCodeConstraintMaxTotalOnFailure integer value for a diagnostic coded as
  // 'Constraint max total on failure' type.
  CONSTRAINT_MAX_TOTAL_ON_FAILURE = 36;
  // DiagnosticCodeConstraintMinTotalOnFailure integer value for a diagnostic coded as
  // 'Constraint min total on failure' type.
  CONSTRAINT_MIN_TOTAL_ON_FAILURE = 37;
  // DiagnosticCodeConstraintMaxTotalOffFailure integer value for a diagnostic coded as
  // 'Constraint max total off failure' type.
  CONSTRAINT_MAX_TOTAL_OFF_FAILURE = 38;
  // DiagnosticCodeConstraintMinTotalOffFailure integer value for a diagnostic coded as
  // 'Constraint min total off failure' type.
  CONSTRAINT_MIN_TOTAL_OFF_FAILURE = 39;
  // DiagnosticCodeConstraintMaxConsecOnFailure integer value for a diagnostic coded as
  // 'Constraint max consec on failure' type.
  CONSTRAINT_MAX_CONSEC_ON_FAILURE = 40;
  // DiagnosticCodeConstraintMinConsecOnFailure integer value for a diagnostic coded as
  // 'Constraint min consec on failure' type.
  CONSTRAINT_MIN_CONSEC_ON_FAILURE = 41;
  // DiagnosticCodeConstraintMaxConsecOffFailure integer value for a diagnostic coded as
  // 'Constraint max consec off failure' type.
  CONSTRAINT_MAX_CONSEC_OFF_FAILURE = 42;
  // DiagnosticCodeConstraintMinConsecOffFailure integer value for a diagnostic coded as
  // 'Constraint min consec off failure' type.
  CONSTRAINT_MIN_CONSEC_OFF_FAILURE = 43;
  // DiagnosticCodeConstraintCannotHaveDayWeekMonthYearShiftPerShift integer value for a diagnostic coded as
  // 'Constraint cannot have day week month year shift per shift' type.
  CONSTRAINT_CANNOT_HAVE_DAY_WEEK_MONTH_YEAR_SHIFT__PER_SHIFT = 44;
  // DiagnosticCodeConstraintCannotHaveDayWeekMonthYearPerMinutesHours integer value for a diagnostic coded as
  // 'Constraint cannot have day week month year per minutes hours' type.
  CONSTRAINT_CANNOT_HAVE_DAY_WEEK_MONTH_YEAR__PER_MINUTES_HOURS = 45;
  // DiagnosticCodeConstraintConsecutiveShiftsRuleNotAllowed integer value for a diagnostic coded as
  // 'Constraint consecutive shifts rule not allowed' type.
  CONSTRAINT_CONSECUTIVE_SHIFTS_RULE_NOT_ALLOWED = 46;
  // DiagnosticCodeConstraintWithLargerPeriodPerSmallPeriodNotAllowed integer value for a diagnostic coded as
  // 'Constraint with larger period per small period not allowed' type.
  CONSTRAINT_WITH_LARGER_PERIOD_PER_SMALL_PERIOD_NOT_ALLOWED = 47;
  // DiagnosticCodeConstraintMinMaxOffTimeForShiftsNotAllowed integer value for a diagnostic coded as
  // 'Constraint min max off time for shifts not allowed' type.
  CONSTRAINT_MIN_MAX_OFF_TIME_FOR_SHIFTS_NOT_ALLOWED = 48;
  // DiagnosticCodeConstraintCannotHaveConsecutiveTimePerMultipleShifts integer value for a diagnostic coded as
  // 'Constraint cannot have consecutive time per multiple shifts' type.
  CONSTRAINT_CANNOT_HAVE_CONSECUTIVE_TIME_PER_MULTIPLE_SHIFTS = 49;
  // DiagnosticCodeCannotGenerateTourPatternsForNonTourShiftTemplate integer value for a diagnostic coded as
  // 'Cannot generate Tour Patterns for non Tour Shift Template' type.
  // The diagnostic is reporting that the shift template to generate a tour pattern for is not a tour shift template.
  CANNOT_GENERATE_TOUR_PATTERNS_FOR_NON_TOUR_SHIFT_TEMPLATE = 50;
  // DiagnosticCodeTourPatternsNeededToScheduleTour integer value for a diagnostic coded as
  // 'Cannot generate shifts for Tour Shift Template that has no Tour Patterns' type.
  // The diagnostic is reporting a tour shift template which does not have a tour pattern.
  TOUR_PATTERNS_NEEDED_TO_SCHEDULE_TOUR = 51;
  // DiagnosticCodeShiftTemplateActivityPlacementMinMaxMustBeMultipleOf5Minutes integer value for a diagnostic coded as
  // 'Shift Template Activity Placement Min Max Must Be Multiple Of 5 Minutes' type.
  // The diagnostic is reporting the shift template activity placement min max must be a multiple of 5 minutes.
  SHIFT_TEMPLATE_ACTIVITY_PLACEMENT_MIN_MAX_MUST_BE_MULTIPLE_OF_5_MINUTES = 52;
  // DiagnosticNoShiftTemplateActivityPlacementSequenciesMatchShiftMinMaxWidth integer value for a diagnostic coded as
  // 'No Shift Template Activity Placement sequences match any Shift Template widths' type.
  // The diagnostic is reporting that there are no placements for the shift template, which would comply with the min and max width.
  NO_SHIFT_TEMPLATE_ACTIVITY_PLACEMENT_SEQUENCES_MATCH_SHIFT_MIN_MAX_WIDTH = 53;
  // DiagnosticCodeInvalidTourPattern integer value for a diagnostic coded as
  // 'Invalid Tour Pattern' type.
  // The diagnostic is reporting the Tour Pattern entity is set with invalid values.
  INVALID_TOUR_PATTERN = 54;
  // DiagnosticCodeInvalidTourAgentCollection integer value for a diagnostic coded as
  // 'Invalid Tour Agent Collection' type.
  // The diagnostic is reporting the Tour Agent Collection entity is set with invalid values.
  INVALID_TOUR_AGENT_COLLECTION = 55;
  // DiagnosticCodeInvalidTourShiftInstanceConfig integer value for a diagnostic coded as
  // 'Invalid Tour Shift Instance Config' type.
  // The diagnostic is reporting the Tour Shift Instance Config entity is set with invalid values.
  INVALID_TOUR_SHIFT_INSTANCE_CONFIG = 56;
  // DiagnosticCodeInvalidTourShiftSegmentConfig integer value for a diagnostic coded as
  // 'Invalid Tour Shift Segment Config' type.
  // The diagnostic is reporting the Tour Shift Segment Config entity is set with invalid values.
  INVALID_TOUR_SHIFT_SEGMENT_CONFIG = 57;
  // DiagnosticCodeTourShiftSegmentConfigOverlap integer value for a diagnostic coded as
  // 'Tour Shift Segment Config overlap' type.
  // The diagnostic is reporting an overlap between tour shift segment configs.
  TOUR_SHIFT_SEGMENT_CONFIG_OVERLAP = 58;
  // DiagnosticCodeTourShiftSegmentConfigDoesNotFit integer value for a diagnostic coded as
  // 'Tour Shift Segment Config does not fit' type.
  // The diagnostic is reporting that a tour shift segment config does not fit in the parent instance.
  TOUR_SHIFT_SEGMENT_CONFIG_DOES_NOT_FIT = 59;
  // DiagnosticCodeTourShiftInstanceConfigOverlap integer value for a diagnostic coded as
  // 'Invalid Tour Shift Instance Config overlap' type.
  // The diagnostic is reporting an overlap between tour shift instance configs in a tour week pattern.
  TOUR_SHIFT_INSTANCE_CONFIG_OVERLAP = 60;
  // DiagnosticCodeWeekPatternNumbersNotUniqueInTourWeekPatterns integer value for a diagnostic coded as
  // 'Week Pattern Numbers bot unique in Tour Week Patterns' type.
  // The diagnostic is reporting a Week Pattern Number being shared between multiple Tour Week Patterns
  WEEK_PATTERN_NUMBERS_NOT_UNIQUE_IN_TOUR_WEEK_PATTERNS = 61;
  // DiagnosticCodeWfmAgentSidsNotUniqueInTourAgentCollections integer value for a diagnostic coded as
  // 'WFM Agent SIDs not unique in Tour Agent Collections' type.
  // The diagnostic is reporting a WFM Agent SID being shared between multiple Tour Agent Collections.
  WFM_AGENT_SIDS_NOT_UNIQUE_IN_TOUR_AGENT_COLLECTIONS = 62;
  // DiagnosticCodeInvalidFirstWeekPatternNumbersNotUniqueInTourAgentCollections integer value for a diagnostic coded as
  // 'First Week Pattern Numbers not unique in Tour Agent Collections' type.
  // The diagnostic is reporting a First Week Pattern Number being shared between multiple Tour Agent Collections.
  FIST_WEEK_PATTERN_NUMBERS_NOT_UNIQUE_IN_TOUR_AGENT_COLLECTIONS = 63;
  // DiagnosticCodeFirstWeekPatternNumbersNotFoundInTourWeekPatterns integer value for a diagnostic coded as
  // 'First Week Patterns not found in Tour Week Patterns' type.
  // The diagnostic is reporting a First Week Pattern Number used be a Tour Agent Collection which is not found in the given Tour Week Patterns.
  FIRST_WEEK_PATTERN_NUMBERS_NOT_FOUND_IN_TOUR_WEEK_PATTERNS = 64;
  // DiagnosticCodeShiftTemplateHasNotAssociatedSchedulingAgentGroups integer value for a diagnostic coded as
  // 'Shift Template Has No Associated Scheduling Agent Groups' type.
  // The diagnostic is reporting a Shift Template with no associated Schedulable Agent Groups.
  SHIFT_TEMPLATE_HAS_NO_ASSOCIATED_SCHEDULING_AGENT_GROUPS = 65;
  // DiagnosticCodeAttemptToBuildSchedulesForInvalidParentNode integer value for a diagnostic coded as
  // 'Attempt To Build Schedules For Invalid Parent Node' type.
  // The diagnostic is reporting an attemplt to build a schedule for an invalid Parent Node.
  ATTEMPT_TO_BUILD_SCHEDULES_FOR_INVALID_PARENT_NODE = 66;
  // DiagnosticCodeSchedulableAgentsDoNotMeetTemplateMinimum integer value for a diagnostic coded as
  // 'Schedulable Agents do not meet Tamplate Minimum' type.
  // The diagnostic is reporting that agents will be auto generated upon building the schedule, unless added manually or agent generation is toggled off.
  SCHEDULABLE_AGENTS_DO_NOT_MEET_TEMPLATE_MINIMUM = 67;
  // DiagnosticCodeSchedulableAgentsDoNotMeetTemplateMaximum integer value for a diagnostic coded as
  // 'Schedulable Agents do not meet Template Maximum' type.
  // The diagnostic is reporting that agents may be auto generated upon building the schedule, unless added manually or agent generation is toggled off.
  SCHEDULABLE_AGENTS_DO_NOT_MEET_TEMPLATE_MAXIMUM = 68;
  // DiagnosticNoOpenTimesInheritedByProgram integer value for a diagnostic coded as
  // 'No Open Times were set or inherited by Program' type
  // The diagnostic is reporting that the program does not have any open time values set directly or through inheritance.
  NO_OPEN_TIMES_SET_OR_INHERITED_BY_PROGRAM = 69;
  // DiagnosticTourAgentCollectionsNeededToScheduleTour integer value for a diagnostic coded as
  // 'Cannot generate shifts for Tour Shift Template that has no Agent Collections for Tour Patterns' type.
  // The diagnostic is reporting that there are no tour agent collections, which are required to schedule the tour pattern.
  TOUR_AGENT_COLLECTIONS_NEEDED_TO_SCHEDULE_TOUR = 70;
}

// Enum representing the type of a performance metric.
enum PerformanceMetricType {
  // The metric is a simplified comparison of FTE calls vs achieved calls.
  FTE_REQUIRED_VS_ACHIEVED_SIMPLE = 0;
  // The metric is an extended comparison of FTE calls vs achieved calls.
  FTE_REQUIRED_VS_ACHIEVED_EXTENDED = 1;
  // The metric analyzes the service level of the schedule.
  SERVICE_LEVEL_ANALYSIS = 2;
  // The metric returns a matrix metric of the service level for the schedule.
  SERVICE_LEVEL_MATRIX = 3;
  // The metric relate to contact handling performance.
  CONTACT_HANDLING_METRICS = 4;
  // The metric relates to the load forecast
  LOAD_FORECAST = 5;
}

// Deprecated.
enum ScheduleShouldInclude {
  // Include only shift instances.
  ONLY_SHIFT_INSTANCES = 0;
  // Include only performance metrics.
  ONLY_PERFORMANCE_METRICS = 1;
  // Include both entities.
  SHIFT_INSTANCES_AND_PERFORMANCE_METRICS = 2;
}

// enum representing the type of a schedule.
enum ScheduleType {
  // Draft schedule.
  DRAFT = 0;
  // Published schedule.
  PUBLISHED = 1;
}

enum SchedulingTargetType {
  // Node will use coverage based scheduling.
  COVERAGE = 0;
  // Node will use service level based scheduling.
  SERVICE_LEVEL = 1;
}

// Filter for schedule selection.
message ScheduleSelector {
  // ID of the schedule to select, not needed for Published schedules.
  int64 schedule_sid = 1;
  // Type of the schedule to select.
  ScheduleType schedule_type = 2;
}

// Indetifier for a skill profile category.
message SkillProfileCategory {
  // enum representing the type of a of skill profile category.
  enum CategoryType {
    // Single skill profile.
    SINGLE_SKILL_PROFILE = 0;
    // Skill profile group.
    SKILL_PROFILE_GROUP = 1;
  }

  // ID of either a skill profile or a skill profile group determined by @skill_profile_category_type.
  int64 skill_profile_category_sid = 1 [jstype = JS_STRING];
  // Category type for @skill_profile_category_sid.
  CategoryType skill_profile_category_type = 2;
}

// Enum representing the options for bitmap creation.
enum BitmapType {
  // The complete bitmap type. Bitmaps will be generated using all relevant pattern data.
  COMPLETE = 0;
  // The bitmaps will be created using only the weekmaps from the patterns.
  ONLY_WEEKMAPS = 1;
  // The bitmaps will be created using only the calendar items from the patterns.
  ONLY_CALENDAR_ITEMS = 2;
}

// Defines the per-skill metrics for SchedulingResultMetric from the Scheduler.
// Wanted to define this in api.v1alpha1.wfm, but had a backwards compatibility error trying to move SchedulingResultMetric.
// Not a top-level entity:
// * No primary-key field.
// * No org_id field.
// * No rpc endpoints, part of SchedulingResultMetric only.
message SchedulingResultMetricForSkillCollection {
  // The total number of minute-width intervals that were scheduled and measured.
  int32 total_internal_intervals = 1;
  // The total number of minute-width intervals that had enough scheduled ftes to meet the predicted call FTEs.
  int32 total_intervals_with_fte_required = 2;
  // The total number of intervals that have unmet predicted call FTEs (not enough scheduled FTEs).
  int32 total_intervals_with_ftes_remaining = 3;
  // The average ratio of interval metrics (min(1,  scheduled/predicted)). A value of 1 means every interval
  //    with predicted call FTEs has enough scheduled FTEs to meet requirements.
  float coverage = 4;
  // Root Mean Square metric for predicted - scheduled FTEs.
  float root_mean_square = 5;
  // Set to TRUE if this object contains valid metrics.
  bool has_result = 6;
  // Pointer to skill collection.
  SkillProfileCategory skill_collection = 7;
}

// Defines a Scheduling Result Metric from the Scheduler.
// Wanted to define this in api.v1alpha1.wfm, but had a backwards compatibility error trying to move it there.
message SchedulingResultMetric {
  // The total number of minute-width intervals that were scheduled and measured.
  int32 total_internal_intervals = 1;
  // The total number of minute-width intervals that had enough scheduled ftes to meet the predicted call FTEs.
  int32 total_intervals_with_fte_required = 2;
  // The total number of intervals that have unmet predicted call FTEs (not enough scheduled FTEs).
  int32 total_intervals_with_ftes_remaining = 3;
  // The average ratio of interval metrics (min(1,  scheduled/predicted)). A value of 1 means every interval
  //    with predicted call FTEs has enough scheduled FTEs to meet requirements.
  float coverage = 4;
  // Root Mean Square metric for predicted - scheduled FTEs.
  float root_mean_square = 5;
  // Set to TRUE if this object contains valid metrics.
  bool has_result = 6;
  // Per-skill metrics.
  repeated SchedulingResultMetricForSkillCollection metrics_by_skill_collection = 7;
}

// Enum representing the state of the history cache.
enum HistoryCacheState {
  // Cache is not loaded and no loading attempts have been made.
  NOT_LOADED = 0;
  // Cache is currently being loaded.
  LOADING = 1;
  // Cache has been successfully loaded.
  LOADING_COMPLETE = 2;
  // Cache was attempted to be loaded but failed, and no new attempts have been made.
  LOADING_FAILED = 3;
}

message ClientHistoryCacheInfo {
  // Current state that a client's cache is at.
  HistoryCacheState state = 1;
  // Percentage estimate of how much of the cache has been loaded.
  int32 progress_percentage = 2;
}

// Defines an ErrorTrace to relate the error to associated log entries.
message ErrorTrace {
  // unique identifier to find any logs related to the error.
  string grpc_trace_bin = 1;
}

// Enum representing the state of a client's initial setup to use WFM.
enum InitialSetupState {
  // Not setup and no set up attempts have been made.
  NOT_SETUP = 0;
  // Currently doing setup tasks.
  SETTING_UP = 1;
  // Set up for client is complete.
  SETUP_COMPLETE = 2;
  // Setup was attempted but failed and no new setup attempts have been made.
  FAILURE = 3;
}

// Represents the status of a client's initial setup and progress to use WFM.
message InitialSetupStatus {
  // Current state that a client is at.
  InitialSetupState state = 1;
  // Progress percentage estimate of the setup process.
  int32 progress_percentage = 2;
  // Any message that a service has in regards to their current state.
  string message = 3;
}

/****************************************************************************************************************************************************/
/****************************************************************************************************************************************************/
/**************************************************************** Adherence **********************************************************************/
/****************************************************************************************************************************************************/
/****************************************************************************************************************************************************/

// The RealTimeManagementState, which is translated as a reduced AgentStatus from the acd service.
enum RealTimeManagementState {
  // Not set.
  UNSPECIFIED = 0;

  // The agent is logged in.
  LOGGED_IN = 1;

  // Not Used for now.
  // ACD_INBOUND_CALL = 2;

  // Not Used for now.
  // DIRECT_INBOUND_CALL = 3;

  // The agent's call is on hold.
  CALL_ON_HOLD = 4;

  // Agent is on an outbound call.
  OUTBOUND_CALL = 5;

  // Not Used for now.
  // INBOUND_CALL = 6;

  // Agent is on a transfered call.
  TRANSFER = 7;

  // Agent is on a conference call.
  CONFERENCE = 8;

  // Agent is ready to accept a call.
  READY = 9;

  // Agent is not_ready to accept a call.
  NOT_READY = 10;

  // The agent is is the wrap up state.
  WRAP_UP = 11;

  // Not Used.
  // AUX_STATE = 12;

  // The agent is logged out.
  LOGGED_OUT = 13;
}

// Represents an agents real time state over a period of time.
message AgentStateSegment {
  // The order that this agent state segment fits into the AgentStateSequence.
  // Sequence starts at 0.
  int32 order_in_rts = 1;
  // The state of the agent during this segment.
  repeated RealTimeManagementState states = 2;
  // The width of this segment in minutes.
  int32 width_in_minutes = 3 [deprecated = true];
  // The width of this segment in seconds.
  int32 width_in_seconds = 4;
}

// Represents a sequence of real time states for a WFM agent.
message AgentStateSequence {
  // ID of the agent that the real time state sequence relates to.
  int64 wfm_agent_sid = 1;
  // The datetime where the agent state sequence starts.
  google.protobuf.Timestamp start_datetime = 2;
  // The list of agent state segments that cover the length of the sequence.
  repeated AgentStateSegment state_segments = 3;
}
