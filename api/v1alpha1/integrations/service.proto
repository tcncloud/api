syntax = "proto3";

package api.v1alpha1.integrations;

import "annotations/authz.proto";
import "api/commons/acd.proto";
import "api/commons/integrations/integrations.proto";
import "api/commons/org/huntgroup.proto";
import "api/commons/perms.proto";
import "google/api/annotations.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "google/type/money.proto";

service Integrations {
  // combine rquest parameters with the config parameters and run the integration method
  rpc Process(ProcessReq) returns (ProcessRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/process";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        },
        {
          permissions: [PERMISSION_AGENT_HUNTGROUP_INTEGRATIONS_VIEW]
        }
      ]
    };
  }

  // get an integration transaction
  rpc GetIntegrationTransaction(GetIntegrationTransactionReq) returns (IntegrationTransaction) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getintegrationtransaction";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc GetIntegrationTransactionReport(GetIntegrationTransactionReportReq) returns (GetIntegrationTransactionReportRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getintegrationtransactionreport";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        },
        {
          permissions: [PERMISSION_AGENT_HUNTGROUP_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc GetIntegrationTransactionReportData(GetIntegrationTransactionReportDataReq) returns (GetIntegrationTransactionReportDataRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getintegrationtransactionreportdata";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc SearchPastTransactions(SearchPastTransactionsRequest) returns (SearchPastTransactionsResponse) {
    option (google.api.http).post = "/api/v1alpha1/integrations/searchpasttransactions";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        },
        {
          permissions: [PERMISSION_AGENT_PLUGINS_VIEW]
        }
      ]
    };
  }
  // GetAggregatedMetadata returns the aggregated metrics about the portal links for a specified date range
  rpc GetAggregatedMetadata(GetAggregatedMetadataReq) returns (GetAggregatedMetadataRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getaggregatemetadata";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // GetPortalLinksByDateRange returns portal link metrics and portal linnk data for specific range
  rpc GetPortalLinksByDateRange(GetPortalLinksByDateRangeReq) returns (GetPortalLinksByDateRangeRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getportallinksbydaterange";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // search integration transactions
  //rpc SearchIntegrationTransactions(SearchIntegrationTransactionsReq) returns (SearchIntegrationTransactionsRes) {
  //  option (google.api.http).post = "/api/v1alpha1/integrations/searchintegrationtransactions";
  //  option (google.api.http).body = "*";
  // option (annotations.authz) = {
  //     sets: [
  //       {
  //         permissions: [PERMISSION_INTEGRATIONS_VIEW]
  //       }
  //     ];
  //   };
  //}

  // create a integration config
  rpc CreateIntegrationConfig(IntegrationConfig) returns (Empty) {
    option (google.api.http).post = "/api/v1alpha1/integrations/createintegrationconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }

  // get an integration config
  rpc GetIntegrationConfig(GetIntegrationConfigReq) returns (IntegrationConfig) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getintegrationconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }

  // update an integration config
  rpc UpdateIntegrationConfig(UpdateIntegrationConfigReq) returns (Empty) {
    option (google.api.http).post = "/api/v1alpha1/integrations/udpateintegrationconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }

  // delete an integration config
  rpc DeleteIntegrationConfig(DeleteIntegrationConfigReq) returns (Empty) {
    option (google.api.http).post = "/api/v1alpha1/integrations/deleteintegrationconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }

  // list all supported integrations
  rpc ListIntegrations(Empty) returns (IntegrationInfos) {
    option (google.api.http).post = "/api/v1alpha1/integrations/listintegrations";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        },
        {
          permissions: [PERMISSION_AGENT_PLUGINS_VIEW]
        }
      ]
    };
  }

  rpc ListIntegrationsForOrg(ListIntegrationsForOrgReq) returns (IntegrationInfos) {
    option (google.api.http).post = "/api/v1alpha1/integrations/listintegrationsfororg";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        },
        {
          permissions: [PERMISSION_AGENT_PLUGINS_VIEW]
        }
      ]
    };
  }

  // lists all the names of the configs for an org's integration type
  rpc ListIntegrationConfigNames(ListIntegrationConfigNamesReq) returns (ListIntegrationConfigNamesRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/listintegrationconfignames";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc ListJourneyConfigs(ListJourneyConfigsReq) returns (IntegrationConfigs) {
    option (google.api.http).post = "/api/v1alpha1/integrations/listjourneyconfigs";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc ListNonJourneyConfigs(ListNonJourneyConfigsReq) returns (IntegrationConfigs) {
    option (google.api.http).post = "/api/v1alpha1/integrations/listnonjourneyconfigs";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // TODO all services looking for payment portal configs should be using the
  // PortalManagerApi service in this same packages
  // CLUDG for the payment portal configs
  rpc CreatePortalConfig(PortalConfig) returns (Empty) {
    option (google.api.http).post = "/api/v1alpha1/integrations/createportalconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // TODO better signature
  // rpc ListPortalConfigs(ListPortalConfigsReq) returns (ListPortalConfigsRes);
  rpc ListPortalConfigs(ListPortalConfigsReq) returns (PortalConfigs) {
    option (google.api.http).post = "/api/v1alpha1/integrations/listportalconfigs";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc UpdatePortalConfig(PortalConfig) returns (Empty) {
    option (google.api.http).post = "/api/v1alpha1/integrations/updateportalconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // TODO better signature
  // rpc GetPortalConfig(GetPortalConfigReq) returns (GetPortalConfigRes);
  rpc GetPortalConfig(GetPortalConfigReq) returns (PortalConfig) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getportalconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // TODO better signature
  // rpc DeletePortalConfig(DeletePortalConfigReq) returns (DeletePortalConfigRes);
  rpc DeletePortalConfig(DeletePortalConfigReq) returns (Empty) {
    option (google.api.http).post = "/api/v1alpha1/integrations/deleteportalconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // TODO deprecate
  rpc UpdatePortalLogo(UpdatePortalLogoReq) returns (Empty) {
    option (google.api.http).post = "/api/v1alpha1/integrations/updateportallogo";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // TODO deprecate
  rpc GetPortalLogo(GetPortalLogoReq) returns (Logo) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getportallogo";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // TODO deprecate. use CreatePortalLinks on the PortalManagerApi
  // pulls the payment_link_config
  // creates an integration config for each set of data, and generates a url for the specific user
  rpc CreatePaymentPortalLinks(CreatePaymentPortalLinksReq) returns (CreatePaymentPortalLinksRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/createpaymentportallinks";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // takes a year in YYYY format and returns the summary of transaction for that year
  rpc Summary(SummaryReq) returns (SummaryRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/summary";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // Lists integration templates that use the passed in integration config
  rpc ListIntegrationTemplatesByConfig(ListIntegrationTemplatesByConfigReq) returns (ListIntegrationTemplatesByConfigRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/integrationtemplatesbyconfig";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  // CallEpicPatient initiates a call to the specified number from the agent using the click to call button within epic
  rpc CallEpicPatient(CallEpicPatientReq) returns (CallEpicPatientRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/callepicpatient";
    option (google.api.http).body = "*";
    option (annotations.authz) = {no_permissions: true};
  }
  // CallEpicPatient initiates a call to the specified number from the agent using the click to call button within epic
  rpc HangUpEpicPatientCall(HangUpEpicPatientCallReq) returns (Empty) {
    option (google.api.http).post = "/api/v1alpha1/integrations/hangupepicpatientcall";
    option (google.api.http).body = "*";
    option (annotations.authz) = {no_permissions: true};
  }
  // GenerateEpicKeyPairs creates 2 key pairs, stores the private keys, and returns the public keys
  rpc GenerateEpicKeyPairs(GenerateEpicKeyPairReq) returns (GenerateEpicKeyPairRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/generateepickeypairs";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSIONS_INTEGRATIONS_KEY_CREATION]
        }
      ]
    };
  }
  rpc PopulateIntegrationLink(PopulateIntegrationLinkReq) returns (PopulateIntegrationLinkRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/populateintegrationlink";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_AGENT_HUNTGROUP_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc ProcessWorkflow(ProcessWorkflowReq) returns (ProcessWorkflowRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/processworkflow";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        },
        {
          permissions: [PERMISSION_AGENT_HUNTGROUP_INTEGRATIONS_VIEW]
        },
        {
          permissions: [PERMISSION_AGENT_ASSISTED_PORTAL]
        }
      ]
    };
  }
  rpc InsertPrivateField(InsertPrivateFieldReq) returns (InsertPrivateFieldRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/insertprivatefield";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc CalculateFees(CalculateFeesReq) returns (CalculateFeesRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/calculatefees";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc GetIntegrationSettings(GetIntegrationSettingsReq) returns (GetIntegrationSettingsRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/getintegrationsettings";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc UpsertIntegrationSettings(UpsertIntegrationSettingsReq) returns (UpsertIntegrationSettingsRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/upsertintegrationsettings";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
  rpc DeliverReceipt(DeliverReceiptReq) returns (DeliverReceiptRes) {
    option (google.api.http).post = "/api/v1alpha1/integrations/deliverreceipt";
    option (google.api.http).body = "*";
    option (annotations.authz) = {
      sets: [
        {
          permissions: [PERMISSION_INTEGRATIONS_VIEW]
        }
      ]
    };
  }
}

message ListJourneyConfigsReq {}
message ListNonJourneyConfigsReq {}

message IntegrationConfigs {
  repeated IntegrationConfig values = 1;
}

message GetIntegrationConfigReq {
  api.commons.integrations.IntegrationType integration_id = 3;
  string name = 4;
  // if this exists, we will do GetIntegrationConfigById, otherwise we will do GetIntegrationConfigByName
  string id = 5;
}

message UpdateIntegrationConfigReq {
  // if this exists, we will do UpdateIntegrationConfigById, otherwise we will do UpdateIntegrationConfigByName
  string id = 3;
  api.commons.integrations.IntegrationType integration_id = 4;
  string name = 5;
  string description = 7;
  Values params = 9;
}

message DeleteIntegrationConfigReq {
  api.commons.integrations.IntegrationType integration_id = 4;
  string name = 5;
  // if this exists we will delete by id, otherwise we delete by integration_id and name
  string id = 6;
}

message ProcessReq {
  // an identifier for this request so we do not do duplicate calls
  // if a IntegrationsApi.Process() call times out, but doesn't fail
  // you can call IntegrationsApi.Process() again with the same request_id.
  // The second call will just return the result of the previous timed out call
  // instead of processing the request a second time.
  string request_id = 8;
  // the id of handler we want to trigger
  api.commons.integrations.IntegrationType integration_id = 3;
  // which integration config is going to be triggered
  api.commons.integrations.RequestMethod method_id = 4;
  string config_name = 5;
  // if this exists, we will fetch the integration by id
  // otherwise we will get the integration by config_name (legecy)
  string config_id = 9;
  // parameters used for this request. These are combined with the parameters stored in the config
  map<string, Value> params = 6;
  // can be left nil, used for verification requests
  repeated Condition conds = 7;
  int64 call_sid = 10;
  api.commons.CallType.Enum call_type = 11;
  api.commons.integrations.RequestOrigin request_origin = 12;
}

message ProcessRes {
  // whether we were successful or the bool result the operation returned.
  bool result = 1;
  // contains the response value from the transaction. This could be an amount for payments
  // an object from inquiries, or it could be nil
  map<string, Value> data = 2;
  // integration name that was called
  string integration = 3;
  // method that was called
  string method = 4;
  // ID of thing we inserted into the db
  // If this is only empty if we fail to insert a transaction (which will return an error) or
  // the transaction is pending. This happens if we call IntegrationsApi.Process() with the same request_id
  // twice, with the first call timing out.
  string transaction_id = 5;
}

message SearchPastTransactionsRequest {
  // which plugin instance made this call.
  // optional. If empty string, we use the int_id
  string plugin_instance_id = 1;
  api.commons.integrations.IntegrationType int_id = 2;
  // which method to look up
  api.commons.integrations.RequestMethod method_id = 3;
  // what keys were given to IntegrationsApi during the ivr processing call
  // and the string representation of the values
  map<string, string> match_fields = 4;
  // max records we will be looking for in the response.
  // no more than 10.
  // if left 0, default of 3 is used.
  uint32 limit = 5;
  // if provided, we will start the search at any transactions older than this timestamp.
  // if left empty, we will start at the current time.
  google.protobuf.Timestamp search_before = 6;
}
message SearchPastTransactionsResponse {
  repeated PastTxEntity values = 1;
}

// simplified view of a IntegrationTransaction
// all values converted to string.
// only shows the request/resposne data, and timestamp it was created on
message PastTxEntity {
  map<string, string> req = 1;
  map<string, string> res = 2;
  google.protobuf.Timestamp created_on = 3;
}

message ListIntegrationsForOrgReq {}

message IntegrationInfos {
  repeated IntegrationInfo values = 1;
}

// IntegrationInfo describes one of our payment sub-services
// it is used in static structures in integrations/adapters/integrations go packages
message IntegrationInfo {
  // the pretty name of this integration. Ex: 'BrainTree'
  string name = 1;
  // identifies which integration handler this is
  api.commons.integrations.IntegrationType integration_id = 2;
  // describes this integration
  string description = 3;
  // what methods are available for this integration
  repeated MethodInfo methods = 4;
  // the plugin fields for this integration.
  // These fields should be set on the plugin level and not the runtime.
  // key is a value starting at api.commons.integrations.Visiblity.VISIBILITY_GROUP
  // and ending at 99 more than that value, or parameters marked VISIBILITY_ANYWHERE
  map<int32, Parameter> group_params = 5;
}

// something callable by a user when given the required parameters
// it is used in static structures in integrations/adapters/integrations go packages

message MethodInfo {
  // the pretty name of the method
  string name = 1;
  // identifies which method this is
  api.commons.integrations.RequestMethod method_id = 2;
  // what type of method call this is: PAYMENT, INQUIRY, or VERIFY
  api.commons.integrations.TransactionType tx_type = 3;
  // what types of fields can/must be sent with the data when calling the method
  repeated Parameter params = 4;
  // the url we contact
  string url = 5;
  // the expected response map will have these values
  // none of these should be required, and none should have a default value
  repeated Parameter response = 6;
  // fields specific to this method that should come over during the runtime
  // key will be a value starting at commnos.public.Visiblity.VISIBILITY_RUNTIME
  // and ending at 99 more than that value, or parameeters marked VISIBLITY_ANYWHERE
  map<int32, Parameter> runtime_params = 7;
}

// Parameter is describes a key/value pair that needs to be on the requeset object
// it is used in static structures in integrations/adapters/integrations go packages
message Parameter {
  // name of parameter. This will be the key of the field in the request payload
  string name = 1;
  // the type of the field. The value of the key value pair needs to be this type in the request payload
  // right now this will be STRING, NUMBER, BOOL
  api.commons.integrations.ValueType param_type = 2;
  // if the field must appear in the request payload or not
  bool required = 3;
  // what is used if the value is not provided
  Value default_value = 4;
  // some names are really ugly, display names are what the user should be shown
  string display_name = 5;
  // means we won't be storing in the database (and there is no way to override)
  bool sensitive = 6;
  // whether this value can be stored in an integration config.
  // If true, we do not allow the value to be put in the config, the value can only
  // be received during processing.
  // true values should be filtered on the front end
  bool runtime_param = 7;
  // tool tip info about the param
  string helper_text = 8;
  // means the parameter is not allowed to be editted in the template builder.
  // template builder can use this to field to make the parameter read_only on the ui.
  // integration_config builder ui can ignore this field.
  // usually fields that are template_locked are ones that require extra work to
  // get an appropriate value for. like "collection_id"
  bool template_locked = 9;
  // what type of data value we accept
  api.commons.integrations.Validation validation = 10;
}

message Empty {}

message GetIntegrationTransactionReq {
  string integration_transaction_id = 1;
}

// get a summary of all the aggregated data between two dates
message GetAggregatedMetadataReq {
  google.protobuf.Timestamp start = 3;
  google.protobuf.Timestamp end = 4;
  api.commons.integrations.RequestMethod method_id = 5;
}

// the metadata values. All values should be numbers or dates
message GetAggregatedMetadataRes {
  int32 views = 1;
  int32 verify_attempts = 2;
  int32 verify_successes = 3;
  int32 payment_attempts = 4;
  int32 payment_successes = 5;
  double payment_amount = 6;
  repeated string fields = 7;
}

// GetIntegrationTransactionReportReq gives summarizes the IntegrationTrasactions between two dates
message GetIntegrationTransactionReportReq {
  google.protobuf.Timestamp start = 3;
  google.protobuf.Timestamp end = 4;
  // field names we want to group the data by
  repeated string group_by = 5;
}

message IntegrationTransactionReportRow {
  api.commons.integrations.IntegrationType integration_id = 5; // integration used
  string integration_name = 17;
  api.commons.integrations.RequestMethod method_id = 6; // external service method
  string method_name = 18;
  api.commons.integrations.TransactionType transaction_type = 7; // payment, data inquiry, etc.
  api.commons.integrations.RequestSource request_source = 8; // email/web/sms/ivr/chat
  // name of the flow that was ran.
  // two flows can have the same method_id but have different flow_names due to
  // the payment portal and ivr portal using same methods, but different flows.
  // group by this to get rid of ivr data in the text2pay results
  string flow_name = 20;
  string campaign_type = 22;
  // the key value pairs for the 'group_by_fields' passed to the request
  map<string, string> group_by_values = 23;

  // aggregate results
  double revenue = 10;
  // date => amount collected subtotals for this row.
  // if the transaction collected = 0 it is not included as an entry.
  // date format for the key is RFC339: "YYYY-MM-DDThh:mm:ss". It will always be in UTC.
  map<string, double> revenue_subtotals = 19;
  int64 success_count = 11;
  int64 failure_count = 12;
  int64 total_count = 13;
  // DD-MM-YYYY format of highest traffic day
  string highest_traffic_date = 15;
  // DD-MM-YYYY format of lowest traffic day
  string lowest_traffic_date = 16;
  // views, verification, invoice, and payment attempts, etc
  map<string, int64> count_metrics = 24;
  // the names of the fields uploaded to portal link, and sent for enriching portal link campaign info
  // to get these values, you must make a separate api call
  repeated string fields = 25;
}

message GetIntegrationTransactionReportRes {
  repeated IntegrationTransactionReportRow values = 1;
}

// Lists the integration transactions that match a flow and campaign
message GetIntegrationTransactionReportDataReq {
  google.protobuf.Timestamp start = 3;
  google.protobuf.Timestamp end = 4;
  // which field_names:value we want to see that was in the last request's group_by
  map<string, string> group_by = 5;
  int32 page_size = 7;
  int32 page_num = 8;
  api.commons.integrations.IntegrationType integration_id = 9;
  int64 search_after_sid = 10;
}
message GetIntegrationTransactionReportDataRow {
  map<string, int64> count_metrics = 1;
  map<string, string> link_data = 2;
  google.protobuf.Timestamp date = 3;
  double payment_amount = 4;
}
message GetIntegrationTransactionReportDataRes {
  repeated GetIntegrationTransactionReportDataRow entities = 1;
  int64 last_transaction_sid = 2;
}

message SearchIntegrationTransactionsReq {
  // optional search parameters
  google.protobuf.Timestamp start_date = 8;
  google.protobuf.Timestamp end_date = 9;
  IntegrationType integration_type = 10;
  RequestMethod request_method = 11;
  TransactionType transaction_type = 12;
  RequestSource request_source = 13;
  TransactionResult result = 14;
  string task_id = 15;
}

message SearchIntegrationTransactionsRes {
  repeated IntegrationTransaction transactions = 1;
}

message IntegrationType {
  api.commons.integrations.IntegrationType integration_id = 1;
}

message RequestMethod {
  api.commons.integrations.RequestMethod method_id = 1;
}

message TransactionType {
  api.commons.integrations.TransactionType transaction_type = 1;
}

message RequestSource {
  api.commons.integrations.RequestSource request_source = 1;
}

message TransactionResult {
  api.commons.integrations.TransactionResult result = 1;
}

// used to list all the config names that we have for an integration handler
message ListIntegrationConfigNamesReq {
  api.commons.integrations.IntegrationType integration_id = 4;
}

message ListIntegrationConfigNamesRes {
  api.commons.integrations.IntegrationType integration_id = 3;
  repeated string names = 4;
}

message GetPaymentLinkConfigReq {
  // the pk of payment_link_config table that contains method we will be creating links for
  string id = 3;
}

// is just the primary key of the config
message DeletePaymentLinkConfigReq {
  string id = 3;
}

// wrapper message so it can be stored in database correctly
message Logo {
  bytes value = 1;
}

// LETS MOVE THIS TO portals.proto WHERE IT BELONGS
message ListPortalConfigsReq {
  PortalConfigId entity = 1;
  google.protobuf.FieldMask mask = 2;
  int32 page_size = 3;
  int32 page = 4;
}

// LETS MOVE THIS TO portals.proto WHERE IT BELONGS
message GetPortalConfigReq {
  PortalConfigId entity = 1;
  google.protobuf.FieldMask mask = 2;
  // DEPRECATED only here because integrations service needs it
  string id = 3;
}

// LETS MOVE THIS TO portals.proto WHERE IT BELONGS
message DeletePortalConfigReq {
  PortalConfigId entity = 1;
  google.protobuf.FieldMask mask = 2;
  // DEPRECATED only here because integrations service needs it
  string id = 3;
}
message UpdatePortalLogoReq {
  // id of portal_config
  string id = 3;
  // is the logo used in the corner of the payment portal screen
  bytes logo = 4;
}
message GetPortalLogoReq {
  // id of portal_config
  string id = 3;
}

message RefreshLinkReq {
  // the integration_config.name for this link that we generated and encoded in the url
  string link_id = 3;
}
message RefreshLinkRes {
  // when the new link will expire
  google.protobuf.Timestamp new_expiry = 1;
}

// same as PaymentPortalLinkConfigDB, but with nicer field types
message PaymentLinkConfig {
  // the pk of payment_link_config table that contains method we will be creating links for
  string id = 19;
  string name = 3;
  string description = 4;
  // the journey collection that will enrich the link data
  string collection_id = 5 [deprecated = true];
  // which integration will be used in the links
  api.commons.integrations.IntegrationType integration_id = 6 [deprecated = true];
  // the verification method. This is used if there is no collection_id to enrich link data
  api.commons.integrations.RequestMethod verification_method_id = 7 [deprecated = true];
  api.commons.integrations.RequestMethod invoice_method_id = 8 [deprecated = true];
  // which method will be called when a payment portal link is process
  api.commons.integrations.RequestMethod payment_method_id = 9 [deprecated = true];
  // journey names and method parameter names might not match one to one
  // the keys of this mapping are journey keys
  // the values are method parameter name the key maps to
  // if we encounter a key that is unknown for the method, integrations checks the name mapping
  // for an alternative key name
  map<string, string> name_mapping = 10;
  // these fields will be used to verify customer identity
  repeated string verification_fields = 11 [deprecated = true];
  // name of the payment portal config that contains all the details for a payment portal screen shown to the user.
  // (visible to link receiver)
  // these don't affect usability of the service, meaning the backend doesn't require any of this info
  string payment_portal_id = 12;
  google.protobuf.Timestamp created_on = 14;
  // how many days till link expires
  int32 expiry_days = 15;
  // whether we are allowed to refresh links
  bool links_refreshable = 16;
  // how many hours a refreshed link is good for
  // 24 == 1 day
  // 2.5 == 2 hours 30 minutes
  // defaults to 1.0
  double refresh_link_valid_hours = 17;
  // how many times we will allow a link to refresh
  int32 max_refresh_times = 18;
  // how we identify the link holder's identity.
  VerificationRequest verification_request = 20;
  // happens directly after the verification request to provide the user a description of the items
  // that need payment, and their amounts
  InvoiceRequest invoice_request = 21;
  // the set of payments the user can choose from. A valid config needs at least one,
  // but can list as many as they want for the user to pick from.
  // only one PaymentRequest will be processed
  repeated PaymentRequest payment_requests = 22;
  map<string, Value> base_data = 23;
  // a marshalled PaymentTemplates proto message
  PaymentLinkConfigTemplates templates = 24;
  // the name of the profile used to generate this profile
  string payment_profile_name = 25;
}

message PaymentLinkConfigTemplates {
  // template string like: "{{name}} thanks for paying {{amount}}"
  // it shows up on the receipt text sent after payment is taken
  // values are populated from what values we know from verification, or in the integration_config
  // so the link designer should not use data that will not be given to tcn at some point to validate a user.
  string receipt_sms_template = 1;
  // text shows up as from this phone number
  string receipt_sms_source_phone = 2;
  // shows up in the email body, is a template string like above
  string receipt_email_template = 3;
  // email shows up as from this address
  string receipt_email_from_addr = 4;
  // template string for the receipt shown in the ui
  string receipt_template = 5;
  // template string for the invoice shown in the ui
  string invoice_template = 6;
}

// VerificationRequest processes verifies
// the 'verification_fields' match in both an input payload, and the response
message VerificationRequest {
  // the set of actions that need to happen to get a payload that can be used to verify against the verification_fields
  // the verification handler in the service will always populate this with a request containing
  // the integration_config_id data and static data from the user
  // each result will be given as a request the result of all previous responses, so order matters.
  repeated Request verification_requests = 1;
  // the fields to verify against
  repeated Parameter verification_fields = 2;
}
message PaymentRequest {
  // the field names the user is expected to fill out for this payment
  // the ui should display the parameter's display_name but send to the server the parameter name
  repeated Parameter payment_fields = 5;
  // set of actions that need to happen to get a payload that can be used for the payment_request
  // the payment handler in the service will always populate this with a request containing
  // the integration_config_id data, but if that is not enough data for the payment the user is allowed to list out more requests here.
  // the results of all these method calls will be merged into one payload that is given to the payment_request.
  // each result will be given as a request the result of all previous responses, so order matters.
  repeated Request payment_request_payload = 1;
  // the request to perform
  Request payment_request = 2;
  // a name for this request to show to the user.  "cc_payment", "ACH Payment" or something else
  string name = 3;
  // a description of this request to show to the user
  string description = 4;
}
message InvoiceRequest {
  // set of actions that need to happen to get a payload that can be used for the invoice_request
  // the verification handler in the service will always populate this with a request with the data used in verifiation
  // but if that is not enough data for the payment the user is allowed to list out more requests here.
  // the results of all these method calls will be merged into one payload that is given to the invoice_request.
  // each result will be given as a request the result of all previous responses, so order matters.
  repeated Request invoice_request_payload = 2;
  Request invoice_request = 3;
  // removes these keys from the response so they are not shown to the user
  repeated string filter_response_keys = 4;
}
message Request {
  oneof val {
    // look up the values from this journey collection
    string journey_collection_id = 3;
    // call this method to get the data
    MethodCall method_call = 4;
    // look up data from this config
    string config_id = 5;
  }
  // add in this static data
  map<string, Value> static_data = 6;
  // rename the keys to the values in the response from 'val'
  map<string, string> rename_response_keys = 7;
  // reassigns the names in key to be the value's validation
  map<string, Validation> reassign_validations = 8;
}

// This type only exists because typescript can't handle
// a map with an enum as a value from another packages
// map<string, api.commons.integrations.Validation>
message Validation {
  api.commons.integrations.Validation enum = 1;
}

message MethodCall {
  api.commons.integrations.IntegrationType integration_id = 1;
  api.commons.integrations.RequestMethod method_id = 2;
}

message PortalConfigs {
  repeated PortalConfig values = 1;
}
message ListPaymentLinkConfigsReq {}
message PaymentLinkConfigs {
  repeated PaymentLinkConfig values = 1;
}
message ListLinksReq {}

message CreatePaymentPortalLinksReq {
  // the pk of link_config table that contains method we will be creating links for
  string link_config_id = 3;
  // when the link expires. blank means it never expires
  google.protobuf.Timestamp expiry = 4;
  // each index represents one map of user data we need a link for
  // should contain the sms/email id that is going to use this link at "_task_id"
  repeated Task user_data = 5;
}

message CreatePaymentPortalLinksRes {
  // each url maps to the same index on the request.user_data
  repeated string urls = 1;
}

message SummaryReq {
  // a num in YYYY format
  int32 year = 3;
}

message SummaryRes {
  CalendarSummary year_summary = 1;
  repeated CalendarSummary month_summaries = 2;
  repeated CalendarSummary week_summaries = 3;
}

message CalendarSummary {
  // calendar_num is in either YYYY, MM, or WW format
  int32 calendar_num = 1;
  TransactionSummary summary = 2;
  // an array of "pairs" with the integration type and it's transaction summary
  repeated IntegrationTypeSummary type_summaries = 3;
}

message IntegrationTypeSummary {
  api.commons.integrations.IntegrationType integration_type = 1;
  TransactionSummary integration_summary = 2;
}

message TransactionSummary {
  int64 total_transactions_attempted = 1;
  int64 total_transactions_completed = 2;
  int64 total_transactions_failed = 3;
  double total_amount_collected = 4;
  double avg_amount_collected = 5;
}

message ListIntegrationTemplatesByConfigReq {
  string integration_config_name = 2;
}

message ListIntegrationTemplatesByConfigRes {
  repeated IntegrationTemplateInfo integration_templates = 1;
}

message IntegrationTemplateInfo {
  int64 broadcast_template_sid = 1;
  string template_name = 2;
}

// DEPRECATED
message CopyPaymentLinkConfigReq {
  string id = 3;
}

// DEPRECATED
message CopyPaymentLinkConfigRes {
  string new_name = 1;
}

// DEPRECATED
message ProfileName {
  string name = 1;
}

// DEPRECATED
message PaymentProfiles {
  repeated PaymentProfile values = 1;
}

// DEPRECATED
message PaymentProfile {
  string verification = 8;
  string invoice = 9;
  repeated string payments = 10;
}

// DEPRECATED
message UnknownField {
  // the name of the field we are missing to make a complete payment link config
  string name = 1;
  // by default matches name
  // this is the name the user wants the field displayed as
  string display_name = 5;
  // the reason we need this field.
  // will point to an api call, or form that is listing the field as required
  string reason_needed = 2;
  // all the sources that are possible this field could come from
  // it is not allowed to give a provided field with a FieldSource
  // not in this list
  repeated api.commons.integrations.FieldSource potential_sources = 3;
  // all the fields in here will be potential fields we could use from api calls, or config look ups
  // THIS COULD BE LEFT BLANK IF THE SERVER HAS NO SUGGESTIONS
  // none of these suggestions have to be used, the user can just "write in" a ProvidedField
  repeated ProvidedField suggested_fields = 4;
}

// DEPRECATED
message ProvidedField {
  // the name of the field as it was asked for in UnknownField.
  // This is the field the *server* is looking for, so it *must* be a field
  // that was in the UnknownField list on the Profile
  string name = 1;
  // by default matches name
  // this is the name the user wants the field displayed as
  string display_name = 6;
  // what name the field will be called in the original location
  // 'alt_name' can be left blank if it is the same as 'name'
  string alt_name = 2;
  // what source provides this field?
  //  - provided info uploaded when creating the link
  //  - provided by the verification/invoice/payment config/journey data source
  //  - provided by the verification/invoice/payment api call
  api.commons.integrations.FieldSource provided_by = 3;
  // here for future use.
  int32 provided_by_details_num = 4;
  // here for future use
  string provided_by_details_str = 5;
}

message Values {
  map<string, Value> values = 1;
}

// kind of like a json value, but we don't support circular references
message Value {
  oneof val {
    string str_val = 1;
    double num_val = 2;
    bool bool_val = 3;
    google.protobuf.Timestamp time_val = 4;
    CompositeVal comp_val = 6;
    int64 int_val = 7;
  }
  // whether this value should be allowed to be stored
  bool sensitive = 5;
  // what type of data value we *want* to validate as.
  // a value does *not* have to match the validation enum.
  // a value that does not match its validation enum is just invalid.
  api.commons.integrations.Validation validation = 8;
}

// represents either a field name whose value needs to be looked up in the payload
// or a static string value
message FieldOrStr {
  oneof val {
    string field = 1;
    string str_val = 2;
  }
}

// represents the individual parts of a string, where some of the parts are
// fields in the payload, and other parts are static strings
// CompositeVal cannot handle circular references. Meaning you cannot have two
// values that contain fields of each other in the same payload.
// Fields that are not found when built into a string will throw an error
message CompositeVal {
  repeated FieldOrStr parts = 1;
}
message Condition {
  // json path to the result ex: path.to.the.0.result
  string key = 1;
  // what operation we are confirming
  api.commons.integrations.CompareOperation op = 2;
  // we support comparing strings, numbers and bools
  Value value = 3;
}

message IntegrationConfig {
  string id = 1;
  api.commons.integrations.IntegrationType integration_id = 4;
  string name = 6;
  string description = 7;
  Values params = 9;
  bool deleted = 10;
  google.protobuf.Timestamp created_on = 11;
  // alternative names that map to parameter names.
  MapString alias = 13;
  // these conditions will be checked on the integration's response. If any evaluate to false, the integration method will fail
  Conditions conds = 14;
  api.commons.integrations.RequestMethod method_id = 15;
}

message IntegrationTransaction {
  string integration_transaction_id = 1;
  string task_id = 4;
  api.commons.integrations.IntegrationType integration_id = 5; // integration used
  api.commons.integrations.RequestMethod method_id = 6; // external service method
  api.commons.integrations.TransactionType transaction_type = 7; // payment, data inquiry, etc.
  api.commons.integrations.RequestSource request_source = 8; // email/web/sms/ivr/chat
  api.commons.integrations.TransactionResult result = 9; // success/failure
  double amount_collected = 10;
  Values request_data = 11;
  Values response_data = 12; // response from external service
  google.protobuf.Timestamp created_on = 13;
  string config_name = 14;
  Conditions conds = 15;
  api.commons.integrations.RequestOrigin request_origin = 16;
}

message MapString {
  map<string, string> values = 1;
}

message Conditions {
  repeated Condition values = 1;
}

message Task {
  // the data used to fetch info about this task when the user clicks on a link
  map<string, Value> values = 1;
  // the sms_id, email_id, etc that can be used to identify what generated this link
  string task_id = 2;
  // the type of the source for this link. ex: Email, Sms, Chat
  api.commons.integrations.RequestSource src = 3;
}

// PORTALS //

message PortalConfigId {
  string id = 3;
}

// all these things will show up on the portal screen to the receiver of
// the link contact info should look like the company who is using the portal
// (not tcn)
message PortalConfig {
  // reserved names: receipt_sms_template, receipt_email_template,
  // receipt_sms_source_phone, receipt_email_from_addr
  reserved 9 to 12;
  string id = 21;
  string name = 22;
  string description = 23;
  // link to pull up a chat with customer service
  string chat_client_link = 2;
  string contact_email = 3;
  string contact_phone = 4;
  string postal_code = 5;
  string city = 6;
  string state = 7;
  string company_name = 8;
  // is the logo used in the corner of the portal screen
  bytes logo = 13;
  // is the primary color used for the portal screen
  string primary_color = 14;
  // accent color used on the portal screen
  string secondary_color = 15;
  string street_address = 19;
}

message PortalLinkId {
  string id = 3;
}
message PortalLink {
  string id = 3;
  string portal_id = 4;
  // DONT USE
  string plugin_instance_id = 5 [deprecated = true];
  string portal_config_id = 6;
  string task_id = 7;
  map<string, Value> data = 8;
  map<string, Value> metadata = 9;
  google.protobuf.Timestamp last_edited = 10;
}

message PortalId {
  string id = 3;
}
message Portal {
  string id = 3;
  string name = 4;
  string description = 5;
  string portal_config_id = 6;
  repeated string plugin_inst_ids = 7;
  PortalType ptype = 8;
  google.protobuf.Timestamp last_edited = 9;
  // the portal definition this came from
  string definition_name = 11;
  // each item in "segments" represents a task for the user.
  // the user must choose and complete one of the FlowChoices in each position
  // in the "segments" array to be considered complete
  PortalSegments portal_segments = 13;
}

message PortalSegments {
  repeated PortalSegment portal_segments = 1;
}

message PortalText {
  string verification_header = 1;
  string verification_footer = 2;
  string payment_header = 3;
  string payment_footer = 4;
  string receipt_header = 5;
  string receipt_footer = 6;
  string invoice_header = 7;
  string invoice_footer = 8;
}
message PortalType {
  oneof data {
    PaymentPortal payment_portal = 1;
    // contains info needed for ivr payment
    IVRPortal ivr_portal = 2;
  }
}
message PaymentPortal {
  api.commons.integrations.VerificationFlow verification = 8;
  api.commons.integrations.InvoiceFlow invoice = 9;
  repeated api.commons.integrations.PaymentFlow payments = 10;
  PortalText portal_text = 20;
}

message IVRPortal {}

message PluginInstanceId {
  string id = 3;
}
message PluginInstance {
  string id = 3;
  string name = 4;
  string description = 5;
  // the plugin type name/label. Ex: 'Experian Payments'
  string plugin_definition = 6;
  Values data = 7;
  Values metadata = 10;
  google.protobuf.Timestamp last_edited = 9;
  api.commons.integrations.RequestMethod method_id = 12 [deprecated = true];
  repeated api.commons.integrations.RequestMethod display_methods = 13;
}

// PortalLinkTransactionRow is all the metrics about a portal link,
// and how it was used in any integration transactions.
message PortalLinkTransactionRow {
  // all this from the PortalLink.Metadata map
  int32 views = 1;
  int32 verify_attempts = 2;
  int32 verify_successes = 3;
  int32 payment_attempts = 4;
  int32 payment_successes = 5;
  double payment_amount = 6;
  google.protobuf.Timestamp date = 7;

  // from PortalLink.Data map
  map<string, Value> link_data = 8;
}

// GetPortalLinksByDateRangeReq gives a paginated view of portal links
message GetPortalLinksByDateRangeReq {
  string org_id = 1;
  string region_id = 2;
  google.protobuf.Timestamp start = 3;
  google.protobuf.Timestamp end = 4;
  int32 page_size = 5;
  int32 page_num = 6;
  api.commons.integrations.RequestMethod method_id = 7;
}

// GetPortalLinksByDateRangeRes returns a page of data
message GetPortalLinksByDateRangeRes {
  repeated PortalLinkTransactionRow rows = 2;
}

message CallEpicPatientReq {
  // The PhoneAgentID is the user’s ID in the phone system (TCN), which indicates to the phone system (TCN) which user is initiating a call.
  // At least one of PhoneAgentID and OriginPhoneExtension must be populated.
  // The property will always be sent, although it may not be populated.
  string PhoneAgentID = 1;
  // The extension used as the phone number for the call initiated from Epic.
  // At least one of PhoneAgentID and OriginPhoneExtension must be populated.
  // The property will always be sent, although it may not be populated.
  string OriginPhoneExtension = 2;
  // The phone number that should be dialed.
  string PhoneNumber = 3;
  // The internal ID of the record in Epic that represents this call.
  // The phone system can store the ID to allow later linking of reports,
  // and to update Epic with information about the call if necessary in the future.
  // The property will always be sent, although it may not be populated.
  string EpicCallID = 4;
}

message CallEpicPatientRes {
  // A unique identifier for the call in the phone system. The VoiceSessionID.
  string PhoneSystemCallID = 1;
}

message HangUpEpicPatientCallReq {
  // The PhoneAgentID is the user’s ID in the phone system (TCN), which indicates to the phone system (TCN) which user is initiating a call.
  // At least one of PhoneAgentID and OriginPhoneExtension must be populated.
  // The property will always be sent, although it may not be populated.
  string PhoneAgentID = 1;
  // The extension used as the phone number for the call initiated from Epic.
  // At least one of PhoneAgentID and OriginPhoneExtension must be populated.
  // The property will always be sent, although it may not be populated.
  string OriginPhoneExtension = 2;
  // The internal ID of the record in Epic that represents this call.
  string EpicCallID = 3;
}

message GenerateEpicKeyPairReq {
  reserved 2;
  reserved "server";
  string org_id = 1;
  repeated string servers = 3;
}

message GenerateEpicKeyPairRes {
  string production_public_key = 1;
  string non_production_public_key = 2;
}

// PortalSegment contains a set a flows where user must complete one of set.
// usually this is selected by the user.
// Example:
// with payment portal, our payment step would have a WorkflowChoices like this:
// PortalSegment{
//  workflow_choices: [
//    <Credit Card Workflow>,
//    <ACH Workflow>,
//    <PayPal Workflow>,
//  ]
// }
// The user doesn't need to do all the choices, just needs to select one to complete.
message PortalSegment {
  repeated PortalWorkflow workflow_choices = 1;
  string header_text = 2;
  string footer_text = 3;
}

// a PortalWorkflow is an entity that describes a set of segments that must be completed in sequence.
// each segment is fed the data as input, and the result is merged on top of the input.
// after completing all the segments successfully, we consider the flow completed.
// A Flow also comes with the user defined template, form_fields, opts, and text.
// None of these are required but will affect how the information is shown to the user.
message PortalWorkflow {
  reserved 1, 5;
  reserved "plugin_instance_id", "opts";
  // the set of actions on the integrations api that must be executed in order
  repeated Action actions = 2;
  // the template that belongs with the result dataset.
  Template template = 3;
  // the data that appears on the user form. This is untrusted data.
  repeated api.commons.integrations.FieldDefinition form_fields = 4;
  // text presented to the user for this flow
  string header_text = 6 [deprecated = true]; //moving to the Portal Segment, workflow specific instruction will be on the fields helper text
  string footer_text = 7 [deprecated = true]; //moving to the Portal Segment, workflow specific instruction will be on the fields helper text
  // if true we do not perform the actions in the "segments" array
  // instead we check pass/fail demo conditions and return demo results
  bool demo_mode = 8;
  repeated Condition demo_fail_conditions = 9;
  repeated Condition demo_pass_conditions = 10;
  map<string, string> demo_results = 11;
  string workflow_definition_name = 12;
}

// an Action is 1 api execution + optional rename of result data step.
message Action {
  reserved 1, 4;
  reserved "rename", "workflow_definition_name";
  // the global data for this action.
  string plugin_instance_id = 2;
  // when a flow is executed if we find in the result any keys that match
  // the keys in rename, we will restructure the keys to the matching
  // value in these map's.
  map<string, string> restructure_before = 5;
  map<string, string> restructure_after = 6;
  string action_definition_name = 7;
  // the data that controls optional functionality for some flows.
  map<string, string> opts = 8;
}

// template is a container for the different template types on each flow.
// each flow definition can have 0-1 templates. Right now we only have Templates
// on invoice flows, but that might not always be the case.
message Template {
  oneof val {
    api.commons.integrations.Invoices invoice_template = 1;
    api.commons.integrations.Receipt receipt_template = 2;
    api.commons.integrations.Payment payment_template = 3;
  }
}

message PopulateIntegrationLinkReq {
  int64 client_sid = 1;
  int64 agent_sid = 2;
  int64 call_sid = 3;
  .api.commons.CallType.Enum call_type = 4;
  string scheduled_callback_id = 5;
  api.commons.org.IntegrationLink integration_link = 6; // all params above are going to use MailMerge to populate the fields on integration link
}

message PopulateIntegrationLinkRes {
  api.commons.org.IntegrationLink integration_link = 1;
}

message ProcessWorkflowReq {
  // portal link id is optional depending on the type of portal being processed
  // if it is specified, we merge in the link data to the request params
  string portal_link_id = 1;
  string portal_id = 2;
  // segment tells us which workflow segment needs processing
  int32 segment = 3;
  // which choice in the workflow array to be processed
  int32 choice = 4;
  // params are what the user fills out before it is processed.
  // It will be merged with plugin instance data and potentially link data
  map<string, Value> params = 5;
  int64 call_sid = 6;
  api.commons.CallType.Enum call_type = 7;
  api.commons.integrations.RequestOrigin request_origin = 8;
}

message ProcessWorkflowRes {
  bool success = 1;
  // the response data from the process
  map<string, Value> data = 2;
}

enum PrivateFieldType {
  UNKNOWN = 0;
  PRIVATE_KEY = 1;
}

message InsertPrivateFieldReq {
  string name = 1;
  string value = 2;
  PrivateFieldType private_field_type = 3;
}

message InsertPrivateFieldRes {
  int32 private_field_id = 1;
}

message CalculateFeesReq {
  repeated api.commons.integrations.Fee fees = 2;
  map<string, Value> params = 3; // form fields collected during portal execution. Some data cannot be set at the plugin level because it is a runtime parameter.
  int64 call_sid = 4; // used for BI
  api.commons.CallType.Enum call_type = 5; // used for BI
  api.commons.integrations.RequestOrigin request_origin = 6; // used for BI
}

message CalculateFeesRes {
  map<string, google.type.Money> calculated_fees = 1; // key: fee name, field: fee amount
  google.type.Money total_amount_due = 2;
}

message IntegrationSettings {
  repeated api.commons.integrations.IntegrationType allowed_integrations = 1;
  // there is probably potential for more org specific settings within integrations that we can store in the future.
}

message GetIntegrationSettingsReq {}

message GetIntegrationSettingsRes {
  repeated api.commons.integrations.IntegrationType allowed_integrations = 1;
}

message UpsertIntegrationSettingsReq {
  IntegrationSettings entity = 1;
}

message UpsertIntegrationSettingsRes {}

message DeliverReceiptReq {
  oneof delivery_method {
    EmailReceipt email_receipt = 3;
    // adding sms, and pdf download in the future if requested
  }
  string receipt_id = 6; // used to look up the populated receipt template in tmp storage
}

message EmailReceipt {
  string to_addr = 1;
}

message DeliverReceiptRes {
  // empty for now, can send back an fts url if we decide to allow them to download a pdf of the receipt
}
